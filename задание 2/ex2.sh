#! /bin/bash
# bash ex2.sh tihiy_don.txt byteStat.csv fileStat.csv
infile=$1 # присваиваем переменным значения из аргументов
byteStat=$2
fileStat=$3
filesize=`stat -c%s $infile` # вычисляем размер файла
echo > $byteStat 
declare -A bytes # объявляем словарь с байтами
while read offset hex char # Читаем файл по одному байту значение попадает в переменную hex
do
decbyte=$((16#$hex)) # По заданию байты должны быть от 0 до 255, поэтому переводим hex в десятичное число
if [ ${bytes[$decbyte]+_} ] # Проверяем есть ли такое число в словаре
then bytes[$decbyte]=$((${bytes[$decbyte]}+1)) # Если есть добавляем к соответствующему ключу единицу
else bytes+=( [$decbyte]=1 ) # если нет такого ключа добавляем его и присваиваем значение 1
fi
done < <(xxd -c 1 $infile) # эта конструкция указывает что переменные offset, hex и char заполняются из вывода команды xxd -c 1 ( -с 1 означает что берется 1 байт)

uniq_bytes=0 # эта переменная - счетчик уникальных байтов
declare p # объясвляем массив куда будем вероятности записывать
H=0 # Сюда будем добавлять энтропию файла
for (( i=0;i<256;i++)) #так как по условию в файле отчете по байтовой статистике надо чтобы байты шли по порядку делаем цикл
do
if [ ${bytes[$i]+_} ] #Если байт с номером i есть в словаре  
then
pi=$(echo "${bytes[$i]}/$filesize" | bc -l) #если есть считаем вероятность появления этого байта в файле
H=$(echo "$H+$pi*l($pi)" | bc -l) # а потом добавялем к текущему значению энтропии Р*log(Pi)
echo "байт $i;${bytes[$i]};$pi" >> $byteStat # Выводим в файл статистику байта
let 'uniq_bytes+=1' # для статистики всего файла прибавляем единицу к счетчику уникальных байтов
p+=( $pi ) # Добавляем вероятность появления байта в массив р
else
echo "байт $i;0;0" >> $byteStat #Если такого номера в словаре нет, вывводим в файл строку
fi
done
H=$(echo "-1*$H" | bc -l) # меняем знак у энтропии(см формулу)
echo -e "N = $filesize\nK = $uniq_bytes\nH = $H" > $fileStat #выводим в статистику файла полученные данные
